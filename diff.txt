diff --git a/DEPLOYMENT.md b/DEPLOYMENT.md
index 9706c2b..7081856 100644
--- a/DEPLOYMENT.md
+++ b/DEPLOYMENT.md
@@ -159,7 +159,7 @@ Should return JSON:
   "code": 200,
   "data": {
     "download": {
-      "url": "https://download-worker.com/test-file.txt?sign=...&hashSign=...&ipSign=..."
+      "url": "https://download-worker.com/test-file.txt?sign=...&hashSign=...&workerSign=...&additionalInfo=...&additionalInfoSign=..."
     },
     "meta": {
       "path": "/test-file.txt"
@@ -173,17 +173,19 @@ Should return JSON:
 
 ## Integration with Download Workers
 
-This landing worker generates three signatures for the download worker:
+This landing worker生成三段 HMAC 签名，以及一个带有 AES-GCM origin snapshot 的 `additionalInfo`：
 
 1. **sign**: Original signature from URL (already verified)
    - Format: `HMAC-SHA256(path, expire)`
 2. **hashSign**: Base64-encoded path signature
    - Format: `HMAC-SHA256(base64(path), expire)`
-3. **ipSign**: Path and IP binding signature
-   - Format: `HMAC-SHA256(JSON.stringify({path: "/file", ip: "1.2.3.4"}), expire)`
-   - This prevents signature reuse across different files by the same IP
+3. **workerSign**: Path + worker binding signature
+   - Format: `HMAC-SHA256(JSON.stringify({path: "/file", worker_addr: "https://download-worker.com"}), expire)`
+4. **additionalInfo.encrypt**: AES-256-GCM 加密的 origin snapshot（`ip_addr/country/continent/region/city/asn`），与 `pathHash/filesize/expireTime/idle_timeout` 一起由 `additionalInfoSign` 保护
 
-Your download worker (e.g., `simple-alist-cf-proxy`) should verify all three signatures.
+Download Worker 会根据 `CHECK_ORIGIN` 设置解密 `encrypt` 并校验当前请求是否与 Landing Worker 签发时一致。
+
+Your download worker (e.g., `simple-alist-cf-proxy`) should verify所有签名，并在需要时执行 origin 绑定。
 
 ### Fast Redirect Mode
 
diff --git a/README.md b/README.md
index 6afb7e1..28be6f1 100644
--- a/README.md
+++ b/README.md
@@ -15,7 +15,7 @@ A simplified Cloudflare Workers project for AList plain file downloads with Turn
 This worker acts as a landing page that:
 1. Receives user requests with signed URLs
 2. Optionally verifies Turnstile tokens
-3. Generates `hashSign` and `ipSign` signatures
+3. Generates `hashSign`, `workerSign`, and an AES-GCM encrypted origin snapshot (`additionalInfo.encrypt`)
 4. Redirects users to download workers with proper authentication
 
 ## Environment Variables
@@ -79,15 +79,16 @@ https://landing-worker.example.com/path/to/file.txt?sign=SIGNATURE
 ```
 GET /info?path=/path/to/file.txt&sign=SIGNATURE
 ```
-Returns JSON with download URL including `hashSign` and `ipSign`.
+Returns JSON with download URL including `hashSign`, `workerSign`, `additionalInfo`, and `additionalInfoSign`.
 
 ## Signature Algorithm
 
 1. **sign**: `HMAC-SHA256(path, expire)`
 2. **hashSign**: `HMAC-SHA256(base64(path), expire)`
-3. **ipSign**: `HMAC-SHA256(clientIP, expire)`
+3. **workerSign**: `HMAC-SHA256(JSON.stringify({path, worker_addr}), expire)`
+4. **additionalInfo.encrypt**: AES-256-GCM encrypted JSON snapshot of the client (`ip_addr`, country/continent/region/city, ASN). The payload plus metadata (`pathHash`, `filesize`, `expireTime`, `idle_timeout`) is signed via `additionalInfoSign = HMAC-SHA256(additionalInfo, expire)`.
 
-All signatures use the format: `base64(hmac):expire`
+All signatures use the format `base64(hmac):expire` and share the same `TOKEN`. The download worker derives its own AES key from `TOKEN` to decrypt the snapshot and enforce `CHECK_ORIGIN`.
 
 ## Changes from Original
 
@@ -102,7 +103,7 @@ This is a simplified version of `alist-crypt-worker-client` with the following c
 - ❌ Advanced settings (retry limits, parallelism, connections)
 
 ### Added
-- ✅ Direct signature generation (hashSign, ipSign)
+- ✅ Direct signature generation (sign/hashSign/workerSign) and AES origin snapshot encryption
 - ✅ Download worker load balancing
 - ✅ Strict sign verification with recalculation check
 
diff --git a/src/worker.js b/src/worker.js
index a5ac224..1a0abce 100644
--- a/src/worker.js
+++ b/src/worker.js
@@ -9,6 +9,11 @@ import {
   calculateIPSubnet,
   applyVerifyHeaders,
 } from './utils.js';
+import {
+  buildOriginSnapshot,
+  encryptOriginSnapshot,
+  getClientIp,
+} from './origin-binding.js';
 import { createChallenge, verifySolution } from 'altcha-lib';
 import { renderLandingPage } from './frontend.js';
 import { createRateLimiter } from './ratelimit/factory.js';
@@ -974,12 +979,7 @@ async function checkCfRatelimit(env, clientIP, ipv4Suffix, ipv6Suffix, bindingNa
   return { allowed: success, ipSubnet };
 }
 
-const extractClientIP = (request) => {
-  const raw = request.headers.get('CF-Connecting-IP');
-  if (!raw) return '';
-  const [first] = raw.split(',');
-  return first ? first.trim() : '';
-};
+const extractClientIP = (request) => getClientIp(request) || '';
 
 const ensureIPv4 = (request, ipv4Only) => {
   if (!ipv4Only) return null;
@@ -1177,8 +1177,11 @@ const fetchFilesizeFromCache = async (config, pathHash) => {
   return 0;
 };
 
-const createAdditionalParams = async (config, decodedPath, clientIP, signExpire, idleTimeoutSeconds, options = {}) => {
+const createAdditionalParams = async (config, request, decodedPath, clientIP, signExpire, idleTimeoutSeconds, options = {}) => {
   if (!config.appendAdditional) return null;
+  if (!request) {
+    throw new Error('request missing for additional info');
+  }
   let { sizeBytes, expireTime, fileInfo } = options;
   const safeIdleTimeoutSeconds =
     Number.isFinite(idleTimeoutSeconds) && idleTimeoutSeconds >= 0
@@ -1225,11 +1228,22 @@ const createAdditionalParams = async (config, decodedPath, clientIP, signExpire,
     expireTime = Math.min(expireTime, maxAllowedExpire);
   }
 
+  const clientIpForOrigin = getClientIp(request);
+  if (!clientIpForOrigin) {
+    throw new Error('client ip missing for origin binding');
+  }
+  const snapshot = buildOriginSnapshot(request.cf, clientIpForOrigin);
+  if (!snapshot) {
+    throw new Error('origin snapshot unavailable');
+  }
+  const encrypt = await encryptOriginSnapshot(snapshot, config.token);
+
   const payload = JSON.stringify({
     pathHash,
     filesize: sizeBytes,
     expireTime,
     idle_timeout: safeIdleTimeoutSeconds,
+    encrypt,
   });
   const rawAdditionalInfo = encodeTextToBase64(payload);
   const additionalInfo = rawAdditionalInfo.replace(/=+$/, '');
@@ -1239,6 +1253,7 @@ const createAdditionalParams = async (config, decodedPath, clientIP, signExpire,
 
 const createDownloadURL = async (
   config,
+  request,
   { encodedPath, decodedPath, sign, clientIP, sizeBytes, expireTime, fileInfo },
   ctx = null
 ) => {
@@ -1275,18 +1290,13 @@ const createDownloadURL = async (
   const workerSignData = JSON.stringify({ path: decodedPath, worker_addr: workerBaseURL });
   const workerSign = await hmacSha256Sign(config.signSecret, workerSignData, expire);
 
-  const ipRange = calculateIPSubnet(clientIP, config.ipv4Suffix, config.ipv6Suffix) || clientIP || '';
-  const ipSignData = JSON.stringify({ path: decodedPath, ip: ipRange });
-  const ipSign = await hmacSha256Sign(config.signSecret, ipSignData, expire);
-
   const downloadURLObj = new URL(encodedPath, workerBaseURL);
   downloadURLObj.searchParams.set('sign', sign);
   downloadURLObj.searchParams.set('hashSign', hashSign);
   downloadURLObj.searchParams.set('workerSign', workerSign);
-  downloadURLObj.searchParams.set('ipSign', ipSign);
 
   if (config.appendAdditional) {
-    const additionalParams = await createAdditionalParams(config, decodedPath, clientIP, expire, idleTimeoutSeconds, {
+    const additionalParams = await createAdditionalParams(config, request, decodedPath, clientIP, expire, idleTimeoutSeconds, {
       sizeBytes,
       expireTime,
       fileInfo,
@@ -2467,7 +2477,7 @@ const handleInfo = async (request, env, config, rateLimiter, ctx) => {
     config.minBandwidthBytesPerSecond,
     config.maxDurationSeconds
   );
-  let downloadURL = await createDownloadURL(config, {
+  let downloadURL = await createDownloadURL(config, request, {
     encodedPath,
     decodedPath,
     sign,
@@ -3202,7 +3212,7 @@ const handleFileRequest = async (request, env, config, rateLimiter, ctx) => {
       config.maxDurationSeconds
     );
 
-    const downloadURL = await createDownloadURL(config, {
+    const downloadURL = await createDownloadURL(config, request, {
       encodedPath,
       decodedPath,
       sign,
