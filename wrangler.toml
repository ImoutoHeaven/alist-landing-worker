name = "alist-landing-worker"
main = "dist/worker.js"
compatibility_date = "2024-01-01"

[observability]
[observability.logs]
enabled = true
head_sampling_rate = 1
invocation_logs = true
persist = true

# Environment variables (configure these in Cloudflare Dashboard or use secrets)
# [vars]
# TOKEN = "your-hmac-token"
# WORKER_ADDRESS_DOWNLOAD = "https://worker1.example.com,https://worker2.example.com"
# UNDER_ATTACK = "false"
# FAST_REDIRECT = "false"
# AUTO_REDIRECT = "false"          # Auto-redirect to download URL after verification
#                                   # Default: "false" (show landing page with download button)
#                                   # When "true": Immediately redirect (302) to download URL after
#                                   #              ALTCHA/Turnstile verification completes
#                                   # When "false": Show landing page, user must click download button
#                                   # Use case: Direct download links vs. user-confirmation page
# TURNSTILE_SITE_KEY = ""
# TURNSTILE_SECRET_KEY = ""
#
# # ═══════════════════════════════════════════════════════════════
# # ⚠️ NEW: Turnstile Token Binding (防止打码平台 Token 转移攻击)
# # ═══════════════════════════════════════════════════════════════
# #
# # Purpose: Bind Cloudflare Turnstile tokens to the IP address that passed verification
# # Security: Prevents attackers from using proxy IPs to pass Turnstile, then transferring
# #           the token to their own high-speed IP for downloading
# #
# # Attack Scenario (WITHOUT token binding):
# # 1. Attacker uses paid proxy IP (1.1.1.1) → passes Turnstile → gets token_abc
# # 2. Attacker intercepts the /info request
# # 3. Attacker uses own IP (2.2.2.2) + token_abc → gets download link
# # 4. Result: Bypassed Turnstile with low cost (proxy IPs are expensive, own IPs are cheap)
# #
# # Protection (WITH token binding):
# # 1. Proxy IP (1.1.1.1) passes Turnstile → token_abc recorded with IP 1.1.1.1
# # 2. Attacker tries to use IP (2.2.2.2) + token_abc
# # 3. Worker detects IP mismatch (2.2.2.2 ≠ 1.1.1.1) → returns 403 Forbidden
# # 4. Token can only be used once (access_count limit)
# #
# # Requirements:
# # - DB_MODE must be set (d1, d1-rest, or custom-pg-rest)
# # - For custom-pg-rest: Run init.sql to create TURNSTILE_TOKEN_BINDING table and functions
# # - Token binding is automatically disabled if DB_MODE is empty (fallback to stateless mode)
# #
# # Configuration:
# TURNSTILE_TOKEN_BINDING = "true"             # Enable/disable token binding
#                                               # Default: "true"
#                                               # Set to "false" to disable (use stateless Turnstile)
#                                               # Automatically disabled if DB_MODE=""
#
# TURNSTILE_TOKEN_TTL = "10m"                  # Token validity duration
#                                               # Format: {number}{unit} where unit is h/m/s
#                                               # Examples: "10m", "600s", "0.16h"
#                                               # Default: "10m" (10 minutes)
#                                               # Should match Cloudflare Turnstile token expiry
#
# TURNSTILE_TOKEN_TABLE = "TURNSTILE_TOKEN_BINDING"  # Database table name
#                                                      # Default: "TURNSTILE_TOKEN_BINDING"
#                                                      # Must match table created by init.sql
#
# TURNSTILE_COOKIE_EXPIRE_TIME = "2m"              # TTL for stateless binding cookie/token
#                                                   # Format: h/m/s (e.g. "2m", "120s")
#                                                   # Default: "2m" (must be <= Turnstile token TTL)
#
# TURNSTILE_EXPECTED_ACTION = "download"           # Action string passed to turnstile.render
#                                                   # Default: "download"
# TURNSTILE_ENFORCE_ACTION = "true"                # Verify siteverify.action matches expected action
#                                                   # Default: "true" (set "false" to skip action check)
# TURNSTILE_ENFORCE_HOSTNAME = "false"             # Verify siteverify.hostname against allowlist
#                                                   # Default: "false"; enable only when you provide allowlist
# TURNSTILE_ALLOWED_HOSTNAMES = "landing.example.com"  # Comma-separated allowlist when HOSTNAME enforcement is on
#                                                        # Example: "landing.example.com,landingv2.example.com"
#
# # ═══════════════════════════════════════════════════════════════
# # ⚠️ NEW: ALTCHA Proof-of-Work Anti-Bot Protection (防爬虫 PoW 验证)
# # ═══════════════════════════════════════════════════════════════
# #
# # Purpose: Protect /info endpoint from automated scripts and bots
# # Technology: ALTCHA - Privacy-first, self-hosted Proof-of-Work challenge system
# # Security: Client-side computational challenge prevents automated attacks (no cookies, GDPR compliant)
# #
# # How it works:
# # 1. User visits landing page → Worker generates ALTCHA challenge (HMAC-signed)
# # 2. Browser solves PoW challenge (~10 seconds of computation, configurable)
# # 3. JavaScript calls /info with solution → Worker verifies solution (stateless or stateful)
# # 4. Stateless mode: Relies on solution expiry (ALTCHA_TOKEN_EXPIRE, default 3 minutes)
# # 5. Stateful mode (DB_MODE set): Records token hash in ALTCHA_TOKEN_LIST table, prevents replay attacks
# #
# # Attack Scenarios Prevented:
# # - Direct curl to /info endpoint (missing PoW solution → 403)
# # - Replay attacks (token hash recorded in DB → second use returns 403)
# # - IP switching (token bound to client IP → different IP returns 403)
# # - Path hijacking (token bound to file path → different path returns 403)
# #
# # Configuration:
# ALTCHA_ENABLED = "true"                 # Enable ALTCHA protection for /info endpoint
#                                          # Default: "false"
#                                          # When enabled: /info requires valid PoW solution
#                                          # Direct curl to /info → 403 ALTCHA solution required
#
# ALTCHA_DIFFICULTY = "250000"             # PoW computational difficulty (maxnumber parameter)
#                                          # Default: "250000" (~10 seconds on modern browsers)
#                                          # Calculation time: ~difficulty / 25000 seconds
#                                          # Examples:
#                                          #   50000  → ~2 seconds (light protection)
#                                          #   250000 → ~10 seconds (recommended)
#                                          #   500000 → ~20 seconds (heavy protection)
#                                          # Note: Higher = more secure but worse UX
#
# ALTCHA_TOKEN_EXPIRE = "3m"               # PoW solution validity duration
#                                          # Default: "3m" (3 minutes)
#                                          # Format: {number}{unit} where unit is h/m/s
#                                          # Examples: "3m", "180s", "0.05h"
#                                          # Rationale: Short expiry reduces replay attack window
#                                          # ALTCHA official recommends 20-60min, but we use 3min
#                                          # because tokens are only for signing download links
#
# PAGE_SECRET = ""                         # ALTCHA HMAC signing key (optional)
#                                          # Default: Uses TOKEN value if not set
#                                          # Recommended: Use different key from TOKEN for defense in depth
#                                          # Format: Any string (e.g., random hex, UUID)
#                                          # Example: "altcha-hmac-secret-key-2024"
#
# ALTCHA_TOKEN_BINDING_TABLE = "ALTCHA_TOKEN_LIST"  # ALTCHA Token 表名（Stateful 模式可自定义，默认 ALTCHA_TOKEN_LIST）
#
# # Replay Attack Prevention (Stateful Mode - Requires Database):
# # When DB_MODE is set (d1, d1-rest, or custom-pg-rest):
# # - Worker records ALTCHA token hash in ALTCHA_TOKEN_LIST table after verification
# # - Token bound to: Client IP + File Path + Expiry Time
# # - Second use of same token → 403 ALTCHA token already used (replay attack detected)
# # - Token expiry → 403 ALTCHA token expired
# # - IP mismatch → 403 ALTCHA token IP mismatch
# # - Path mismatch → 403 ALTCHA token filepath mismatch
# #
# # Stateless Mode (No Database - DB_MODE not set):
# # - Relies on ALTCHA solution's built-in expiry check (verifySolution())
# # - No replay attack prevention (50ms race condition window exists)
# # - Suitable for low-security scenarios or when database is unavailable
# #
# # Requirements for Stateful Mode:
# # - DB_MODE must be set (d1, d1-rest, or custom-pg-rest)
# # - For custom-pg-rest: Run init.sql to create ALTCHA_TOKEN_LIST table and functions:
# #   * landing_verify_altcha_token() - Verify token and check replay
# #   * landing_record_altcha_token() - Record token usage
# #   * landing_cleanup_expired_altcha_tokens() - Cleanup expired tokens
# # - For D1/D1-REST: Tables auto-created by ensureTables()
# #
# # Performance Notes:
# # - ALTCHA verification integrated into unified check (1 RTT for cache + rate + turnstile + altcha)
# # - PostgreSQL: Single RPC call landing_unified_check() includes ALTCHA verification
# # - D1 Binding: Single db.batch([cache, rate, turnstile, altcha]) - 1 RTT
# # - D1 REST: Single batch API call with 4 queries - 1 RTT (optimized from 4 RTT)
# # - Token recording happens asynchronously (ctx.waitUntil) - no response blocking
# #
# # Error Codes:
# # - 403: ALTCHA solution required (missing solution)
# # - 403: ALTCHA verification failed (invalid solution signature)
# # - 403: ALTCHA error: {details} (solution parsing/hashing error)
# # - 463: ALTCHA token IP mismatch (stateful mode, different IP)
# # - 463: ALTCHA token expired (stateful mode, TTL exceeded)
# # - 463: ALTCHA token already used (stateful mode, replay attack detected)
# # - 463: ALTCHA token filepath mismatch (stateful mode, different file)
# #
# # Example Configuration (Stateless - No Database):
# #   ALTCHA_ENABLED = "true"
# #   ALTCHA_DIFFICULTY = "250000"
# #   ALTCHA_TOKEN_EXPIRE = "3m"
# #   PAGE_SECRET = "my-altcha-secret"
# #
# # Example Configuration (Stateful - With PostgreSQL):
# #   ALTCHA_ENABLED = "true"
# #   ALTCHA_DIFFICULTY = "250000"
# #   ALTCHA_TOKEN_EXPIRE = "3m"
# #   PAGE_SECRET = "my-altcha-secret"
# #   DB_MODE = "custom-pg-rest"
# #   POSTGREST_URL = "https://postgrest.example.com"
# #   VERIFY_HEADER = "X-Auth-Token"
# #   VERIFY_SECRET = "your-secret"
# #
# # Example Configuration (Heavy Protection - Turnstile + ALTCHA):
# #   UNDER_ATTACK = "true"
# #   TURNSTILE_SITE_KEY = "your-site-key"
# #   TURNSTILE_SECRET_KEY = "your-secret-key"
# #   TURNSTILE_TOKEN_BINDING = "true"
# #   ALTCHA_ENABLED = "true"
# #   ALTCHA_DIFFICULTY = "250000"
# #   DB_MODE = "custom-pg-rest"
# #   # Result: Double protection (Human verification + PoW challenge)
# #   # Verification order: ALTCHA first, then Turnstile, then sign
#
# # How it works:
# # 1. User passes Turnstile verification (Cloudflare siteVerify) → Worker records token hash + IP (access_count=0)
# # 2. User calls /info → Worker checks: token exists? IP matches? access_count < 1?
# # 3. If all checks pass → signs download link → asynchronously updates access_count=1
# # 4. Subsequent requests with same token → rejected (access_count >= 1)
# #
# # Error Codes:
# # - 463: Turnstile token IP mismatch (token used from different IP)
# # - 464: Turnstile token already used (access_count limit exceeded)
# # - 465: Turnstile token expired (TTL exceeded)
# #
# # Performance Notes:
# # - Token binding check is integrated into unified check (single RTT for cache + rate + token)
# # - Token INSERT happens immediately after siteVerify (records first IP that passed)
# # - Token UPDATE happens asynchronously after response (no blocking)
# # - PostgreSQL: 3 RTT → 1 RTT (unified check with token binding)
# # - D1 Binding: 3 RTT → 1-2 RTT (batch read + async write)
# # - D1 REST: 3 RTT → 3 RTT (sequential, no optimization possible)
# #
# # Example Configuration:
# #   UNDER_ATTACK = "true"
# #   TURNSTILE_SITE_KEY = "your-site-key"
# #   TURNSTILE_SECRET_KEY = "your-secret-key"
# #   TURNSTILE_TOKEN_BINDING = "true"
# #   TURNSTILE_TOKEN_TTL = "10m"
# #   DB_MODE = "custom-pg-rest"
# #   POSTGREST_URL = "https://postgrest.example.com"
# #   VERIFY_HEADER = "X-Auth-Token"
# #   VERIFY_SECRET = "your-secret"
#
# SIGN_SECRET = ""
# IPV4_ONLY = "false"
# VERIFY_HEADER = ""
# VERIFY_SECRET = ""
# # ⚠️ NEW: Multi-Authentication Header Support (comma-separated format)
# # You can now specify multiple authentication header/secret pairs for different services
# # Format: "header1,header2,header3"
# # Example for AList + PostgREST:
# #   VERIFY_HEADER = "X-Auth-Token,X-Postgrest-Auth"
# #   VERIFY_SECRET = "alist-secret-key,postgrest-secret-key"
# # Requirements:
# #   - Both arrays must have the same length (if non-empty)
# #   - No spaces between commas: "header1,header2" (spaces will be trimmed automatically)
# #   - All header/secret pairs will be sent in requests to AList /api/fs/get and PostgREST
# # Backward Compatible: Single value still works: VERIFY_HEADER = "X-Auth-Token"
# IF_APPEND_ADDITIONAL = "true"           # Append additionalInfo parameters to download URLs
# ALIST_ADDRESS = "https://alist.example.com"  # Fallback AList base URL when appending expiry (ADDRESS/ALIST_BASE_URL also supported)
# MIN_ALLOWED_BANDWIDTH = "10"            # Minimum allowed download bandwidth (Mbps)
# MIN_DURATION_TIME = "1h"                # Minimum expiry duration for generated links (supports h/m/s suffix)
# MAX_DURATION_TIME = "4h"               # Optional: cap download link lifetime (supports h/m/s suffix, e.g. "4h", "1d")
# # ACTION 可选值:
# # - block: 返回 403
# # - verify-pow: 仅要求 ALTCHA PoW 验证
# # - verify-turn: 仅要求 Turnstile 验证
# # - verify-both: 同时要求 PoW 和 Turnstile
# # - pass-web: 跳过验证，强制渲染 landing page
# # - pass-server: 跳过验证，强制 302 重定向
# # - pass-asis: 跳过验证，遵循 FAST_REDIRECT 配置
#
# BLACKLIST_PREFIX = "/private,/admin"
# BLACKLIST_ACTION = "block"
# WHITELIST_PREFIX = "/public,/shared"
# WHITELIST_ACTION = "pass-asis"
# EXCEPT_PREFIX = "/guest,/public"
# EXCEPT_ACTION = "block-except"   # 支持所有 ACTION 值 + "-except" 后缀（如 block-except, verify-both-except, pass-asis-except）
#
# # ⚠️ NEW: Path INCLUDES Matching (Match keywords anywhere in path)
# # In addition to PREFIX (startsWith) matching, you can now use INCLUDES (contains) matching
# # Path is split into: dirPath (folder) + fileName (file name) + fullPath (complete path)
# # Example: "/folder1/folder2/file.txt"
# #   - dirPath: "/folder1/folder2"
# #   - fileName: "file.txt"
# #   - fullPath: "/folder1/folder2/file.txt"
# #
# # INCLUDES matching modes (comma-separated keywords, no spaces):
# BLACKLIST_DIR_INCLUDES = "private,confidential,secret"     # Match folder path containing keywords
# BLACKLIST_NAME_INCLUDES = "backup,bak,.tmp"                # Match file name containing keywords
# BLACKLIST_PATH_INCLUDES = "temp,cache"                     # Match full path containing keywords
# WHITELIST_DIR_INCLUDES = "public,shared"                   # Match folder path containing keywords
# WHITELIST_NAME_INCLUDES = "readme,license"                 # Match file name containing keywords
# WHITELIST_PATH_INCLUDES = "docs,assets"                    # Match full path containing keywords
# EXCEPT_DIR_INCLUDES = "test,debug"                         # Match folder path containing keywords
# EXCEPT_NAME_INCLUDES = "log,tmp"                           # Match file name containing keywords
# EXCEPT_PATH_INCLUDES = "staging,dev"                       # Match full path containing keywords
# #
# # Union Logic (OR):
# # - PREFIX and INCLUDES are evaluated together (any match triggers action)
# # - Multiple keywords in INCLUDES are OR-ed (any keyword match triggers)
# # Example: BLACKLIST_PREFIX="/admin" + BLACKLIST_DIR_INCLUDES="private,secret"
# #   → Matches: /admin/file.txt (prefix) OR /test/private/file.txt (dir includes) OR /test/secret/file.txt (dir includes)
# #
# # Matching Examples:
# # 1. BLACKLIST_DIR_INCLUDES = "private"
# #    → Blocks: /test/private/file.txt (dirPath "/test/private" contains "private")
# #    → Action: "block"
# #
# # 2. WHITELIST_NAME_INCLUDES = "readme"
# #    → Matches: /docs/readme.md (fileName "readme.md" contains "readme")
# #    → Action: "pass-asis" (or configured WHITELIST_ACTION)
# #
# # 3. BLACKLIST_PATH_INCLUDES = "temp"
# #    → Blocks: /test/temp/file.txt (fullPath contains "temp")
# #    → Blocks: /test/file_temp.txt (fullPath contains "temp")
# #    → Action: "block"
# #
# # 4. EXCEPT_DIR_INCLUDES = "staging"
# #    → Paths NOT containing "staging" in dirPath trigger EXCEPT_ACTION
# #    → Example: /prod/file.txt → triggers "block-except" (blocks)
# #    → Example: /staging/file.txt → no action (normal flow)
#
# # Database Mode for IP Rate Limiting
# # Options: "d1" (Cloudflare D1 Binding), "d1-rest" (Cloudflare D1 REST API), "custom-pg-rest" (Custom PostgreSQL + PostgREST)
# # If not set, rate limiting is completely disabled
# DB_MODE = ""
# IPSUBNET_WINDOWTIME_LIMIT = "100"
# WINDOW_TIME = "24h"
# IPV4_SUFFIX = "/32"
# IPV6_SUFFIX = "/60"
# PG_ERROR_HANDLE = "fail-closed"
# CLEANUP_PERCENTAGE = "5"  # 0-100（可为小数），触发过期令牌清理的概率，默认 5%
# BLOCK_TIME = "10m"
#
# # ═══════════════════════════════════════════════════════════════
# # ⚠️ Database Table Initialization Control (Performance Optimization)
# # ═══════════════════════════════════════════════════════════════
# #
# # INIT_TABLES controls whether to create database tables before each RPC/SQL batch call
# # Default: "false" (skip table initialization for optimal performance)
# #
# # How it works:
# # - When "true": Worker calls ensureTables() before every unified check
# #                Creates tables if they don't exist (CREATE TABLE IF NOT EXISTS)
# #                Ensures tables are always available but adds overhead
# # - When "false": Worker skips ensureTables() call completely
# #                 Reduces database round-trips and improves response time
# #                 Tables must be created manually before first use
# #
# # Performance Impact:
# # - "false" (recommended): ~10-50ms faster per request (no table check overhead)
# # - "true" (legacy): Safe but slower (adds CREATE TABLE queries to every request)
# #
# # When to use "true":
# # - First deployment (tables don't exist yet)
# # - Table schema changes (need to update table structure)
# # - Development/testing environments
# # - Automatic recovery after database reset
# #
# # When to use "false":
# # - Production environments (tables already exist)
# # - Performance-critical scenarios
# # - After initial deployment is successful
# #
# # Recommended Workflow:
# # 1. First deployment: INIT_TABLES="true" → Creates all tables
# # 2. Verify tables exist: Check D1 dashboard or run SELECT on tables
# # 3. Switch to production: INIT_TABLES="false" → Optimal performance
# # 4. Schema updates: Temporarily set to "true" → Apply changes → Set back to "false"
# #
# # Tables Created (when INIT_TABLES="true"):
# # - FILESIZE_CACHE_TABLE (filesize cache)
# # - IP_LIMIT_TABLE (IP rate limiting)
# # - TURNSTILE_TOKEN_BINDING (Turnstile token binding)
# # - ALTCHA_TOKEN_LIST (ALTCHA PoW token replay prevention)
# # - SESSION_MAPPING_TABLE (optional, if SESSION_ENABLED="true")
# #
# # Note: For custom-pg-rest mode, you should still run init.sql manually for stored procedures
# #       INIT_TABLES only creates tables, not functions/procedures
# #
# INIT_TABLES = "false"
#
# # D1 (Cloudflare D1 Binding) Rate Limiting - requires DB_MODE="d1"
# # Note: You must also configure d1_databases binding below
# D1_DATABASE_BINDING = "DB"  # Optional, defaults to "DB"
# D1_TABLE_NAME = "IP_LIMIT_TABLE"  # Optional, defaults to IP_LIMIT_TABLE
#
# # D1 REST API Rate Limiting - requires DB_MODE="d1-rest"
# # Use this mode when you cannot use Workers binding (e.g., external API calls)
# D1_ACCOUNT_ID = "your-cloudflare-account-id"
# D1_DATABASE_ID = "your-d1-database-id"
# D1_API_TOKEN = "your-cloudflare-api-token"
# D1_TABLE_NAME = "IP_LIMIT_TABLE"  # Optional, defaults to IP_LIMIT_TABLE
#
# # Custom PostgreSQL + PostgREST Rate Limiting - requires DB_MODE="custom-pg-rest"
# # Use this mode when you have self-hosted PostgreSQL with PostgREST REST API
# # ⚠️ IMPORTANT: You MUST run init.sql on your PostgreSQL database first!
# #   - Creates IP_LIMIT_TABLE table (rate limiting)
# #   - Creates FILESIZE_CACHE_TABLE table (filesize caching)
# #   - Creates TURNSTILE_TOKEN_BINDING table (Turnstile token binding)
# #   - Creates ALTCHA_TOKEN_LIST table (ALTCHA PoW token replay prevention)
# #   - Creates landing_upsert_rate_limit() stored procedure (atomic rate limit)
# #   - Creates landing_upsert_filesize_cache() stored procedure (atomic cache)
# #   - Creates landing_upsert_token_binding() stored procedure (atomic token binding)
# #   - Creates landing_verify_altcha_token() stored procedure (verify ALTCHA token)
# #   - Creates landing_record_altcha_token() stored procedure (record ALTCHA token usage)
# #   - Creates landing_cleanup_expired_tokens() stored procedure (Turnstile token cleanup)
# #   - Creates landing_cleanup_expired_altcha_tokens() stored procedure (ALTCHA token cleanup)
# #   - Creates landing_unified_check() stored procedure (single RTT: cache + rate + turnstile + altcha)
# POSTGREST_URL = "https://your-domain.com/postgrest"  # PostgREST API endpoint (without table name)
# POSTGREST_TABLE_NAME = "IP_LIMIT_TABLE"  # Optional, defaults to IP_LIMIT_TABLE
# # Note: VERIFY_HEADER and VERIFY_SECRET (already defined above) are used for PostgREST authentication
#
# # Session-Based Download Tickets (optional)
# SESSION_ENABLED = "false"                       # Enable UUID session tickets; default disabled
# SESSION_DB_MODE = ""                            # Optional override ("d1", "d1-rest", "custom-pg-rest"); falls back to DB_MODE
# SESSION_D1_DATABASE_BINDING = "SESSIONDB"       # D1 binding for session storage (when SESSION_DB_MODE="d1")
# SESSION_D1_TABLE_NAME = "SESSION_MAPPING_TABLE" # Session table name for D1 / D1-REST
# SESSION_D1_ACCOUNT_ID = ""                      # Required when SESSION_DB_MODE="d1-rest"
# SESSION_D1_DATABASE_ID = ""
# SESSION_D1_API_TOKEN = ""
# SESSION_POSTGREST_URL = "https://your-domain.com/postgrest"  # Required when SESSION_DB_MODE="custom-pg-rest"
# SESSION_POSTGREST_TABLE_NAME = "SESSION_MAPPING_TABLE"
#
# # ═══════════════════════════════════════════════════════════════
# # ⚠️ NEW: Filesize Cache System (Reduce /api/fs/get API Calls)
# # ═══════════════════════════════════════════════════════════════
# #
# # Purpose: Cache file sizes from AList /api/fs/get to reduce API calls
# # Benefits:
# #   - Reduces latency for repeated requests (cache hit = no API call)
# #   - Reduces load on AList server
# #   - Performance optimization: Single RTT for rate limit + cache (unified check)
# #
# # How it works:
# # 1. First request: Calls /api/fs/get, extracts file size, caches it
# # 2. Subsequent requests: Uses cached size (within TTL), skips /api/fs/get
# # 3. TTL expires: Re-fetches from /api/fs/get, updates cache
# #
# # Requirements:
# # - DB_MODE must be set (d1, d1-rest, or custom-pg-rest)
# # - For custom-pg-rest: Run init.sql to create FILESIZE_CACHE_TABLE and stored procedures
# #
# # Configuration:
# FILESIZE_CACHE_TABLE = "FILESIZE_CACHE_TABLE"  # Table name for filesize cache
#                                                 # Default: "FILESIZE_CACHE_TABLE"
#                                                 # This is independent from rate limit table
#
# SIZE_TTL = "24h"                                # Cache TTL (Time To Live)
#                                                 # Format: {number}{unit} where unit is h/m/s
#                                                 # Examples: "24h", "1440m", "86400s"
#                                                 # Default: "24h" (24 hours)
#                                                 # Rationale: File sizes rarely change
#
# # Note: When both rate limiting and caching are enabled, the worker uses
# #       "unified check" to query both in a single database round-trip (RTT optimization).
# #       This reduces latency from 3 RTT → 1 RTT (cache hit) or 2 RTT (cache miss).
#
# # Example Configuration (custom-pg-rest with cache):
# #   DB_MODE = "custom-pg-rest"
# #   POSTGREST_URL = "https://postgrest.example.com"
# #   VERIFY_HEADER = "X-Auth-Token,X-Postgrest-Auth"
# #   VERIFY_SECRET = "alist-secret,postgrest-secret"
# #   FILESIZE_CACHE_TABLE = "FILESIZE_CACHE_TABLE"
# #   SIZE_TTL = "24h"
# #   WINDOW_TIME = "24h"
# #   IPSUBNET_WINDOWTIME_LIMIT = "100"

# # ═══════════════════════════════════════════════════════════════
# # ⚠️ NEW: IDLE Timeout System (Force Active Download Usage)
# # ═══════════════════════════════════════════════════════════════
# #
# # Purpose: Enforce users to download immediately after link generation
# # Prevents hoarding download links for later batch downloading
# #
# # How it works:
# # 1. Landing worker generates download link → writes initial IDLE record (ACCESS_COUNT=0)
# # 2. Proxy worker checks idle timeout → updates ACCESS_COUNT and LAST_ACCESS_TIME
# # 3. If idle timeout exceeded → proxy returns 410 Gone (link expired due to inactivity)
# # 4. additionalInfo.idle_timeout overrides proxy's environment variable (central control)
# #
# # Requirements:
# # - IDLE_TIMEOUT must be non-zero to enable IDLE writes
# # - IDLE_DB_MODE falls back to DB_MODE when not specified
# # - For custom-pg-rest: DOWNLOAD_LAST_ACTIVE_TABLE must exist (see simple-alist-cf-proxy/init.sql)
# #
# # Configuration:
# IDLE_TIMEOUT = "0"                            # IDLE timeout duration (0 = disabled)
#                                                # Format: {number}{unit} where unit is h/m/s
#                                                # Examples: "30m", "1h", "60s"
#                                                # Default: "0" (disabled)
#                                                # When >0: Landing writes initial record, proxy enforces timeout
#
# IDLE_TABLE_NAME = "DOWNLOAD_LAST_ACTIVE_TABLE"  # IDLE tracking table name
#                                                   # Default: "DOWNLOAD_LAST_ACTIVE_TABLE"
#                                                   # Must match table in simple-alist-cf-proxy
#
# # IDLE DB Configuration (fallback to main DB_MODE if not specified)
# # Only configure these if you want separate database for IDLE tracking
# # IDLE_DB_MODE = ""                            # Optional override ("d1", "d1-rest", "custom-pg-rest"); falls back to DB_MODE
# # IDLE_D1_DATABASE_BINDING = ""                # D1 binding for IDLE storage (when IDLE_DB_MODE="d1"); defaults to D1_DATABASE_BINDING
# # IDLE_D1_ACCOUNT_ID = ""                      # Required when IDLE_DB_MODE="d1-rest"; defaults to D1_ACCOUNT_ID
# # IDLE_D1_DATABASE_ID = ""                     # Required when IDLE_DB_MODE="d1-rest"; defaults to D1_DATABASE_ID
# # IDLE_D1_API_TOKEN = ""                       # Required when IDLE_DB_MODE="d1-rest"; defaults to D1_API_TOKEN
# # IDLE_POSTGREST_URL = ""                      # Required when IDLE_DB_MODE="custom-pg-rest"; defaults to POSTGREST_URL
# #
# # Data Flow:
# # 1. Landing worker generates link → includes idle_timeout in additionalInfo (signed)
# # 2. Landing worker writes: (IP_HASH, PATH_HASH, now, ACCESS_COUNT=0) via ctx.waitUntil (async)
# # 3. Proxy receives request → extracts idle_timeout from additionalInfo
# # 4. Proxy checks: (now - LAST_ACCESS_TIME > idle_timeout) → 410 if expired
# # 5. Proxy updates: ACCESS_COUNT++ and LAST_ACCESS_TIME=now
# #
# # Priority:
# # - additionalInfo.idle_timeout (from landing) > proxy env IDLE_TIMEOUT (local)
# # - This allows central control: landing decides timeout policy
# # - Proxy respects per-link timeout: idle_timeout=0 → disables check completely
# #
# # Example Configuration (Enable IDLE with 30min timeout):
# #   IDLE_TIMEOUT = "30m"
# #   IDLE_TABLE_NAME = "DOWNLOAD_LAST_ACTIVE_TABLE"
# #   DB_MODE = "custom-pg-rest"  # IDLE_DB_MODE will fall back to this
# #   POSTGREST_URL = "https://postgrest.example.com"
# #
# # Example Configuration (Separate IDLE Database):
# #   IDLE_TIMEOUT = "1h"
# #   IDLE_DB_MODE = "custom-pg-rest"
# #   IDLE_POSTGREST_URL = "https://idle-postgrest.example.com"
# #   IDLE_TABLE_NAME = "DOWNLOAD_LAST_ACTIVE_TABLE"
# #
# # Performance Notes:
# # - Landing writes IDLE record asynchronously (ctx.waitUntil) - no response blocking
# # - Proxy checks IDLE as part of unified check (1 RTT includes cache + rate + idle)
# # - Table uses composite primary key (IP_HASH, PATH_HASH) for efficient UPSERT
# #
# # Error Handling:
# # - Landing write failure → silent (doesn't block link generation)
# # - Proxy check failure → continues (fail-open for IDLE feature)
# #

# # ═══════════════════════════════════════════════════════════════
# # ⚠️ NEW: Cloudflare Rate Limiter (Binding-based, Stateless/Stateful)
# # ═══════════════════════════════════════════════════════════════
# #
# # Purpose: First-layer rate limiting using Cloudflare's native Rate Limiter binding
# # Benefits:
# #   - Ultra-low latency (<10ms, edge-based enforcement)
# #   - Works in both stateless (DB_MODE="") and stateful (DB_MODE set) modes
# #   - Zero database cost for stateless deployments
# #   - Can be used as additional protection layer when combined with DB rate limiting
# #
# # How it works:
# # 1. Request arrives → CF Rate Limiter checks (based on IP subnet SHA256)
# # 2. If limit exceeded → Return 429 immediately (no DB queries, no verification)
# # 3. If allowed → Continue to ALTCHA/Turnstile verification and DB rate limiting
# #
# # Dual Protection (Stateful Mode):
# # - CF Rate Limiter: Blocks obvious abuse at edge (e.g., 10 req/10s)
# # - DB Rate Limiting: Fine-grained control (e.g., 100 req/24h)
# # - Advantages: CF absorbs high-frequency attacks, DB handles long-term limits
# #
# # Requirements:
# # - Must configure [[rate_limit]] binding in wrangler.toml (see below)
# # - ENABLE_CF_RATELIMITER must be "true" to activate
# # - Binding validation enforced at startup (throws error if binding not found)
# #
# # Configuration:
# ENABLE_CF_RATELIMITER = "false"      # Enable Cloudflare Rate Limiter binding
#                                       # Default: "false" (disabled)
#                                       # Set to "true" to enable first-layer rate limiting
#                                       # Works in both stateless and stateful modes
#                                       # If enabled but binding not found → startup error
#
# CF_RATELIMITER_BINDING = "CF_RATE_LIMITER"  # Rate Limiter binding name
#                                              # Default: "CF_RATE_LIMITER"
#                                              # Must match [[rate_limit]].binding below
#                                              # Change if using custom binding name
#
# # Limiting Key Strategy:
# # - Uses SHA256(IP subnet) as rate limiting key
# # - Respects IPV4_SUFFIX and IPV6_SUFFIX settings (same as DB rate limiting)
# # - Example: IPV4_SUFFIX="/24" → all IPs in 192.168.1.0/24 share the same limit
# #
# # Error Handling:
# # - Binding not found when enabled → Throws startup error
# # - Rate limit exceeded → Returns 429 with Retry-After: 60 header
# # - CF Rate Limiter failure → fail-open (continues to verification/DB)
# #
# # Example Configuration (Stateless Mode):
# #   ENABLE_CF_RATELIMITER = "true"
# #   CF_RATELIMITER_BINDING = "CF_RATE_LIMITER"
# #   DB_MODE = ""  # No database, pure edge rate limiting
# #   IPV4_SUFFIX = "/24"
# #   IPV6_SUFFIX = "/60"
# #
# # Example Configuration (Stateful Dual Protection with ALTCHA):
# #   ENABLE_CF_RATELIMITER = "true"
# #   CF_RATELIMITER_BINDING = "CF_RATE_LIMITER"
# #   ALTCHA_ENABLED = "true"
# #   DB_MODE = "custom-pg-rest"
# #   WINDOW_TIME = "24h"
# #   IPSUBNET_WINDOWTIME_LIMIT = "100"  # 100 requests per 24h (DB layer)
# #   # CF Rate Limiter configured in binding: 10 requests per 10s (edge layer)
# #   # Verification order: CF Rate Limiter → ALTCHA PoW → DB Rate Limit → Download

# D1 Database Binding (for DB_MODE="d1")
# Uncomment and configure this section if using D1 binding mode
# [[d1_databases]]
# binding = "DB"  # Must match D1_DATABASE_BINDING env var (or use default "DB")
# database_name = "alist-ratelimit-db"
# database_id = "your-d1-database-id"

# ═══════════════════════════════════════════════════════════════
# ⚠️ NEW: Cloudflare Rate Limiter Binding (for ENABLE_CF_RATELIMITER="true")
# ═══════════════════════════════════════════════════════════════
#
# Uncomment and configure this section if enabling CF Rate Limiter
# The rate limit rules (period, limit) are configured here, NOT in environment variables
# Documentation: https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/
#
# [[rate_limit]]
# binding = "CF_RATE_LIMITER"  # Must match CF_RATELIMITER_BINDING env var
#
# # Simple Algorithm (Fixed Window)
# # Example: 10 requests per 10 seconds
# simple = { period = 10, limit = 10 }
#
# # Alternative: Sliding Window Algorithm (More accurate)
# # Example: 100 requests per 60 seconds (sliding window)
# # sliding_window = { period = 60, limit = 100 }
#
# # Notes:
# # - period: Time window in seconds (max 86400 = 24h)
# # - limit: Maximum requests per period per key (IP subnet SHA256)
# # - Choose simple for lower latency, sliding_window for more accurate enforcement
# # - These parameters cannot be changed via environment variables
# # - Must redeploy worker to change rate limit rules
#
# # Recommended Configurations for Landing Page:
# #
# # Light Protection (Edge layer, allows human browsing):
# #   simple = { period = 10, limit = 20 }
# #   # 20 requests per 10 seconds = ~2 req/s burst
# #   # Suitable for normal users with slow clicking
# #
# # Medium Protection (Edge layer, blocks simple bots):
# #   simple = { period = 10, limit = 10 }
# #   # 10 requests per 10 seconds = 1 req/s sustained
# #   # Combined with ALTCHA PoW for stronger bot prevention
# #
# # Heavy Protection (Edge + DB + PoW, maximum security):
# #   simple = { period = 10, limit = 5 }
# #   # Edge: 5 req/10s
# #   # DB: 100 req/24h (WINDOW_TIME/IPSUBNET_WINDOWTIME_LIMIT)
# #   # PoW: ALTCHA_DIFFICULTY=250000 (~10s solve time)
# #   # Recommended for UNDER_ATTACK mode

# For local development, create a .dev.vars file with:
# TOKEN=your-token
# WORKER_ADDRESS_DOWNLOAD=https://worker.example.com
