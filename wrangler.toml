name = "alist-landing-worker"
main = "dist/worker.js"
compatibility_date = "2024-01-01"

[observability]
[observability.logs]
enabled = true
head_sampling_rate = 1
invocation_logs = true
persist = true

# Environment variables (configure these in Cloudflare Dashboard or use secrets)
# [vars]
# TOKEN = "your-hmac-token"
# WORKER_ADDRESS_DOWNLOAD = "https://worker1.example.com,https://worker2.example.com"
# UNDER_ATTACK = "false"
# FAST_REDIRECT = "false"
# TURNSTILE_SITE_KEY = ""
# TURNSTILE_SECRET_KEY = ""
#
# # ═══════════════════════════════════════════════════════════════
# # ⚠️ NEW: Turnstile Token Binding (防止打码平台 Token 转移攻击)
# # ═══════════════════════════════════════════════════════════════
# #
# # Purpose: Bind Cloudflare Turnstile tokens to the IP address that passed verification
# # Security: Prevents attackers from using proxy IPs to pass Turnstile, then transferring
# #           the token to their own high-speed IP for downloading
# #
# # Attack Scenario (WITHOUT token binding):
# # 1. Attacker uses paid proxy IP (1.1.1.1) → passes Turnstile → gets token_abc
# # 2. Attacker intercepts the /info request
# # 3. Attacker uses own IP (2.2.2.2) + token_abc → gets download link
# # 4. Result: Bypassed Turnstile with low cost (proxy IPs are expensive, own IPs are cheap)
# #
# # Protection (WITH token binding):
# # 1. Proxy IP (1.1.1.1) passes Turnstile → token_abc recorded with IP 1.1.1.1
# # 2. Attacker tries to use IP (2.2.2.2) + token_abc
# # 3. Worker detects IP mismatch (2.2.2.2 ≠ 1.1.1.1) → returns 403 Forbidden
# # 4. Token can only be used once (access_count limit)
# #
# # Requirements:
# # - DB_MODE must be set (d1, d1-rest, or custom-pg-rest)
# # - For custom-pg-rest: Run init.sql to create TURNSTILE_TOKEN_BINDING table and functions
# # - Token binding is automatically disabled if DB_MODE is empty (fallback to stateless mode)
# #
# # Configuration:
# TURNSTILE_TOKEN_BINDING = "true"             # Enable/disable token binding
#                                               # Default: "true"
#                                               # Set to "false" to disable (use stateless Turnstile)
#                                               # Automatically disabled if DB_MODE=""
#
# TURNSTILE_TOKEN_TTL = "10m"                  # Token validity duration
#                                               # Format: {number}{unit} where unit is h/m/s
#                                               # Examples: "10m", "600s", "0.16h"
#                                               # Default: "10m" (10 minutes)
#                                               # Should match Cloudflare Turnstile token expiry
#
# TURNSTILE_TOKEN_TABLE = "TURNSTILE_TOKEN_BINDING"  # Database table name
#                                                      # Default: "TURNSTILE_TOKEN_BINDING"
#                                                      # Must match table created by init.sql
#
# # How it works:
# # 1. User passes Turnstile verification (Cloudflare siteVerify) → Worker records token hash + IP (access_count=0)
# # 2. User calls /info → Worker checks: token exists? IP matches? access_count < 1?
# # 3. If all checks pass → signs download link → asynchronously updates access_count=1
# # 4. Subsequent requests with same token → rejected (access_count >= 1)
# #
# # Error Codes:
# # - 463: Turnstile token IP mismatch (token used from different IP)
# # - 464: Turnstile token already used (access_count limit exceeded)
# # - 465: Turnstile token expired (TTL exceeded)
# #
# # Performance Notes:
# # - Token binding check is integrated into unified check (single RTT for cache + rate + token)
# # - Token INSERT happens immediately after siteVerify (records first IP that passed)
# # - Token UPDATE happens asynchronously after response (no blocking)
# # - PostgreSQL: 3 RTT → 1 RTT (unified check with token binding)
# # - D1 Binding: 3 RTT → 1-2 RTT (batch read + async write)
# # - D1 REST: 3 RTT → 3 RTT (sequential, no optimization possible)
# #
# # Example Configuration:
# #   UNDER_ATTACK = "true"
# #   TURNSTILE_SITE_KEY = "your-site-key"
# #   TURNSTILE_SECRET_KEY = "your-secret-key"
# #   TURNSTILE_TOKEN_BINDING = "true"
# #   TURNSTILE_TOKEN_TTL = "10m"
# #   DB_MODE = "custom-pg-rest"
# #   POSTGREST_URL = "https://postgrest.example.com"
# #   VERIFY_HEADER = "X-Auth-Token"
# #   VERIFY_SECRET = "your-secret"
#
# SIGN_SECRET = ""
# IPV4_ONLY = "false"
# VERIFY_HEADER = ""
# VERIFY_SECRET = ""
# # ⚠️ NEW: Multi-Authentication Header Support (comma-separated format)
# # You can now specify multiple authentication header/secret pairs for different services
# # Format: "header1,header2,header3"
# # Example for AList + PostgREST:
# #   VERIFY_HEADER = "X-Auth-Token,X-Postgrest-Auth"
# #   VERIFY_SECRET = "alist-secret-key,postgrest-secret-key"
# # Requirements:
# #   - Both arrays must have the same length (if non-empty)
# #   - No spaces between commas: "header1,header2" (spaces will be trimmed automatically)
# #   - All header/secret pairs will be sent in requests to AList /api/fs/get and PostgREST
# # Backward Compatible: Single value still works: VERIFY_HEADER = "X-Auth-Token"
# IF_APPEND_ADDITIONAL = "true"           # Append additionalInfo parameters to download URLs
# ALIST_ADDRESS = "https://alist.example.com"  # Fallback AList base URL when appending expiry (ADDRESS/ALIST_BASE_URL also supported)
# MIN_ALLOWED_BANDWIDTH = "10"            # Minimum allowed download bandwidth (Mbps)
# MIN_DURATION_TIME = "1h"                # Minimum expiry duration for generated links (supports h/m/s suffix)
# BLACKLIST_PREFIX = "/private,/admin"
# BLACKLIST_ACTION = "block"
# WHITELIST_PREFIX = "/public,/shared"
# WHITELIST_ACTION = "pass-asis"
# EXCEPT_PREFIX = "/guest,/public"
# EXCEPT_ACTION = "block-except"
#
# # Database Mode for IP Rate Limiting
# # Options: "d1" (Cloudflare D1 Binding), "d1-rest" (Cloudflare D1 REST API), "custom-pg-rest" (Custom PostgreSQL + PostgREST)
# # If not set, rate limiting is completely disabled
# DB_MODE = ""
# IPSUBNET_WINDOWTIME_LIMIT = "100"
# WINDOW_TIME = "24h"
# IPV4_SUFFIX = "/32"
# IPV6_SUFFIX = "/60"
# PG_ERROR_HANDLE = "fail-closed"
# CLEANUP_PERCENTAGE = "1"  # 0-100 inclusive, decimals allowed (e.g., "0.1" = 0.1%)
# BLOCK_TIME = "10m"
#
# # D1 (Cloudflare D1 Binding) Rate Limiting - requires DB_MODE="d1"
# # Note: You must also configure d1_databases binding below
# D1_DATABASE_BINDING = "DB"  # Optional, defaults to "DB"
# D1_TABLE_NAME = "IP_LIMIT_TABLE"  # Optional, defaults to IP_LIMIT_TABLE
#
# # D1 REST API Rate Limiting - requires DB_MODE="d1-rest"
# # Use this mode when you cannot use Workers binding (e.g., external API calls)
# D1_ACCOUNT_ID = "your-cloudflare-account-id"
# D1_DATABASE_ID = "your-d1-database-id"
# D1_API_TOKEN = "your-cloudflare-api-token"
# D1_TABLE_NAME = "IP_LIMIT_TABLE"  # Optional, defaults to IP_LIMIT_TABLE
#
# # Custom PostgreSQL + PostgREST Rate Limiting - requires DB_MODE="custom-pg-rest"
# # Use this mode when you have self-hosted PostgreSQL with PostgREST REST API
# # ⚠️ IMPORTANT: You MUST run init.sql on your PostgreSQL database first!
# #   - Creates IP_LIMIT_TABLE table (rate limiting)
# #   - Creates FILESIZE_CACHE_TABLE table (filesize caching)
# #   - Creates TURNSTILE_TOKEN_BINDING table (Turnstile token binding)
# #   - Creates landing_upsert_rate_limit() stored procedure (atomic rate limit)
# #   - Creates landing_upsert_filesize_cache() stored procedure (atomic cache)
# #   - Creates landing_upsert_token_binding() stored procedure (atomic token binding)
# #   - Creates landing_cleanup_expired_tokens() stored procedure (token cleanup)
# #   - Creates landing_unified_check() stored procedure (single RTT: cache + rate + token)
# POSTGREST_URL = "https://your-domain.com/postgrest"  # PostgREST API endpoint (without table name)
# POSTGREST_TABLE_NAME = "IP_LIMIT_TABLE"  # Optional, defaults to IP_LIMIT_TABLE
# # Note: VERIFY_HEADER and VERIFY_SECRET (already defined above) are used for PostgREST authentication
#
# # ═══════════════════════════════════════════════════════════════
# # ⚠️ NEW: Filesize Cache System (Reduce /api/fs/get API Calls)
# # ═══════════════════════════════════════════════════════════════
# #
# # Purpose: Cache file sizes from AList /api/fs/get to reduce API calls
# # Benefits:
# #   - Reduces latency for repeated requests (cache hit = no API call)
# #   - Reduces load on AList server
# #   - Performance optimization: Single RTT for rate limit + cache (unified check)
# #
# # How it works:
# # 1. First request: Calls /api/fs/get, extracts file size, caches it
# # 2. Subsequent requests: Uses cached size (within TTL), skips /api/fs/get
# # 3. TTL expires: Re-fetches from /api/fs/get, updates cache
# #
# # Requirements:
# # - DB_MODE must be set (d1, d1-rest, or custom-pg-rest)
# # - For custom-pg-rest: Run init.sql to create FILESIZE_CACHE_TABLE and stored procedures
# #
# # Configuration:
# FILESIZE_CACHE_TABLE = "FILESIZE_CACHE_TABLE"  # Table name for filesize cache
#                                                 # Default: "FILESIZE_CACHE_TABLE"
#                                                 # This is independent from rate limit table
#
# SIZE_TTL = "24h"                                # Cache TTL (Time To Live)
#                                                 # Format: {number}{unit} where unit is h/m/s
#                                                 # Examples: "24h", "1440m", "86400s"
#                                                 # Default: "24h" (24 hours)
#                                                 # Rationale: File sizes rarely change
#
# # Note: When both rate limiting and caching are enabled, the worker uses
# #       "unified check" to query both in a single database round-trip (RTT optimization).
# #       This reduces latency from 3 RTT → 1 RTT (cache hit) or 2 RTT (cache miss).
#
# # Example Configuration (custom-pg-rest with cache):
# #   DB_MODE = "custom-pg-rest"
# #   POSTGREST_URL = "https://postgrest.example.com"
# #   VERIFY_HEADER = "X-Auth-Token,X-Postgrest-Auth"
# #   VERIFY_SECRET = "alist-secret,postgrest-secret"
# #   FILESIZE_CACHE_TABLE = "FILESIZE_CACHE_TABLE"
# #   SIZE_TTL = "24h"
# #   WINDOW_TIME = "24h"
# #   IPSUBNET_WINDOWTIME_LIMIT = "100"

# D1 Database Binding (for DB_MODE="d1")
# Uncomment and configure this section if using D1 binding mode
# [[d1_databases]]
# binding = "DB"  # Must match D1_DATABASE_BINDING env var (or use default "DB")
# database_name = "alist-ratelimit-db"
# database_id = "your-d1-database-id"

# For local development, create a .dev.vars file with:
# TOKEN=your-token
# WORKER_ADDRESS_DOWNLOAD=https://worker.example.com
